1. Do you know why Windows Workflow Foundation failed (https://stackoverflow.com/a/8594359/67824)? Because when you build anything serious, you need to use serious tools (i.e. CODE). You will never build (not to mention maintain) any real production system by dragging rectangles around, pointing arrows between them, and checking some checkboxes. It's just not enough. I know managers like to say that we should "keep things simple", but I like to say "development is never simple", otherwise you wouldn't be reading this blog. CI/CD is exactly the same, people simply don't realize that. I think the crux of the problem is that people treat CI/CD processes as "inferior". Why on earth would you need to write C# code for some simple copy and deploy operations? Let's just have a "copy" task and a "deploy service" task and be done with it. We'll even package them in a nice UI any layman could use, and now we don't even need developers, right? WRONG. Real production CI/CD code can get quite complex, and requires tools that are just as powerful as those used to write services 

To give an example of how seemigly simple things get complex real fast, let's talk about copying stuff. What could be simpler, right? Right, unless you want to control security attributes, timestamps, mirroring, retries, skipping, attributes, long path support, multi threaded copies, moves, monitor source folder, schedule, monitor copy performance, symbolic links, logging... I didn't invent any of these, they are all used in the real world otherwise would not have made it to [robocopy](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/robocopy). Nobody is ever going to create a GUI that captures all that (And if they do, it would be more complex than running the command in a script).

Now let's take a deployment scenario for example. Let's say you have a complex cluster comprised of Service Fabric, Azure Functions, Web Jobs, Event Hubs, Storage accounts, etc. The "GUI way" says hey, let's get a plugin for each task and drag the tasks 

1. What about retries? In my experience, the vast majority of the time you won't have any, and manual intervention would be necessary if any transient error occured during the task's execution (e.g. 503 service unavailable). Even if some saint introduces retries into his task, there is no chance in hell you'd get different parametrized retry policies like exponential backoff. So most times you won't get it, and when you do, it's not going to be good enough. Needless to say, in C# you would just use something like Polly (link) and be done with it real quick.
1. Auto token renewals. Similar to retries, it's a basic capability (renew your token when it expires) and could happen in big deployments. I'm guessing the vast majority of tasks don't have it. In C# it should be pretty simple to write a layer that adds it for all calls.
1. Control - what if you want some logic to decide whether some task executes or not? In UI it's either impossible or weak (like checking a boolean expression).
1. Parametrization. Usually, GUI-based options like closed dropdown lists and checkboxes can't even be passed as parameters (https://stackoverflow.com/questions/50384699/in-vsts-task-groups-is-it-possible-to-parameterise-a-checkbox). For example, if you have a build task with a checkbox for cleaning before building, you can't parametrize it (in some cases you'd have a generic additional compiler flags where you could put it, but it's neither consistent nor universal).
1. Updates. Say a new feature is introduced. Is is practcically a guarantee that feature would hit the SDKs before it hits the VSTS task (if ever, especially if it's a niche/complex feature). It happened to me back in the day when I made the mistake of using the XCodeBuild Jenkins plugin (instead of just executing it myself in bash).
1. Diff. Diffing code is super easy, diffing xmls/jsons that represent GUI - not so much.
1. Fragmentation - for example ARM template, now you have to break it to 20 tasks. Much harder to manage. And what if one of them fails? Maybe you want to roll everything back? So now you need 20 more tasks for the rollback. 
2. OK, so GUI sucks. What is powerful enough then? How about PowerShell? Good question. Let me answer back with a question - when was the last time you wrote a backend service in PowerShell? Never, and for very good reasons (which might be left for another post). For the same exact reasons, PowerShell is NOT powerful enough for serious CI/CD scenarios as well. Anything more than a single file with a few dozen lines becomes incredibly unmanageable (we have thousands of PS code spanning dozens of files and it is a nightmare). If you're reading this blog, your language of choice is probably C# - stick with it (I would turn a blind eye if you decided to use Java, too).

Note that some of the points above can be solved by adding new job layers or plugins, e.g. a generic retry job that retries other jobs. But then you basically go back to workflow - trying to write generic code using UI blocks, and that's just bad. 
Honestly, In my mind CI/CD tools should basically have a single type of task - "run code". You select the language and supply an executable or script file, and they run it. Everything else should be provided via SDKs (which the providers need to write anyway). So everybody wins - providers don't need to write yet another "SDK" (VSTS task), and CI/CD developers are saved from themselves.